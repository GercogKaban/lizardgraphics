<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lizard Graphics: Defragmentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lizard Graphics
   &#160;<span id="projectnumber">0.0.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="index.html">Vulkan Memory Allocator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Defragmentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Interleaved allocations and deallocations of many objects of varying size can cause fragmentation over time, which can lead to a situation where the library is unable to find a continuous range of free memory for a new allocation despite there is enough free space, just scattered across many small free ranges between existing allocations.</p>
<p>To mitigate this problem, you can use defragmentation feature: structure <a class="el" href="struct_vma_defragmentation_info2.html" title="Parameters for defragmentation.">VmaDefragmentationInfo2</a>, function vmaDefragmentationBegin(), vmaDefragmentationEnd(). Given set of allocations, this function can move them to compact used memory, ensure more continuous free space and possibly also free some <code>VkDeviceMemory</code> blocks.</p>
<p>What the defragmentation does is:</p>
<ul>
<li>Updates <a class="el" href="struct_vma_allocation.html" title="Represents single memory allocation.">VmaAllocation</a> objects to point to new <code>VkDeviceMemory</code> and offset. After allocation has been moved, its <a class="el" href="struct_vma_allocation_info.html#abaf12cc4e13fbe5208ca6e5bb1a21c19" title="Handle to Vulkan memory object.">VmaAllocationInfo::deviceMemory</a> and/or <a class="el" href="struct_vma_allocation_info.html#a4a3c732388dbdc7a23f9365b00825268" title="Offset in VkDeviceMemory object to the beginning of this allocation, in bytes. (deviceMemory,...">VmaAllocationInfo::offset</a> changes. You must query them again using vmaGetAllocationInfo() if you need them.</li>
<li>Moves actual data in memory.</li>
</ul>
<p>What it doesn't do, so you need to do it yourself:</p>
<ul>
<li>Recreate buffers and images that were bound to allocations that were defragmented and bind them with their new places in memory. You must use <code>vkDestroyBuffer()</code>, <code>vkDestroyImage()</code>, <code>vkCreateBuffer()</code>, <code>vkCreateImage()</code>, vmaBindBufferMemory(), vmaBindImageMemory() for that purpose and NOT vmaDestroyBuffer(), vmaDestroyImage(), vmaCreateBuffer(), vmaCreateImage(), because you don't need to destroy or create allocation objects!</li>
<li>Recreate views and update descriptors that point to these buffers and images.</li>
</ul>
<h1><a class="anchor" id="defragmentation_cpu"></a>
Defragmenting CPU memory</h1>
<p>Following example demonstrates how you can run defragmentation on CPU. Only allocations created in memory types that are <code>HOST_VISIBLE</code> can be defragmented. Others are ignored.</p>
<p>The way it works is:</p>
<ul>
<li>It temporarily maps entire memory blocks when necessary.</li>
<li>It moves data using <code>memmove()</code> function.</li>
</ul>
<div class="fragment"><div class="line"><span class="comment">// Given following variables already initialized:</span></div>
<div class="line">VkDevice device;</div>
<div class="line"><a class="code" href="struct_vma_allocator.html">VmaAllocator</a> allocator;</div>
<div class="line">std::vector&lt;VkBuffer&gt; buffers;</div>
<div class="line">std::vector&lt;VmaAllocation&gt; allocations;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> uint32_t allocCount = (uint32_t)allocations.size();</div>
<div class="line">std::vector&lt;VkBool32&gt; allocationsChanged(allocCount);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a> defragInfo = {};</div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info2.html#a3cf86ab32c1da779b4923d301a3056ba">allocationCount</a> = allocCount;</div>
<div class="line">defragInfo.pAllocations = allocations.data();</div>
<div class="line">defragInfo.pAllocationsChanged = allocationsChanged.data();</div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info2.html#af78e1ea40c22d85137b65f6b384a4d0a">maxCpuBytesToMove</a> = VK_WHOLE_SIZE; <span class="comment">// No limit.</span></div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info2.html#a94c2c7223d52878445a8cccce396b671">maxCpuAllocationsToMove</a> = UINT32_MAX; <span class="comment">// No limit.</span></div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> defragCtx;</div>
<div class="line">vmaDefragmentationBegin(allocator, &amp;defragInfo, <span class="keyword">nullptr</span>, &amp;defragCtx);</div>
<div class="line">vmaDefragmentationEnd(allocator, defragCtx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(uint32_t i = 0; i &lt; allocCount; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(allocationsChanged[i])</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Destroy buffer that is immutably bound to memory region which is no longer valid.</span></div>
<div class="line">        vkDestroyBuffer(device, buffers[i], <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Create new buffer with same parameters.</span></div>
<div class="line">        <a class="code" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> bufferInfo = ...;</div>
<div class="line">        vkCreateBuffer(device, &amp;bufferInfo, <span class="keyword">nullptr</span>, &amp;buffers[i]);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Bind new buffer to new memory region. Data contained in it is already moved.</span></div>
<div class="line">        <a class="code" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> allocInfo;</div>
<div class="line">        vmaGetAllocationInfo(allocator, allocations[i], &amp;allocInfo);</div>
<div class="line">        vmaBindBufferMemory(allocator, allocations[i], buffers[i]);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="astruct_vk_buffer_create_info_html"><div class="ttname"><a href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_core.h:2547</div></div>
<div class="ttc" id="astruct_vma_allocation_info_html"><div class="ttname"><a href="struct_vma_allocation_info.html">VmaAllocationInfo</a></div><div class="ttdoc">Parameters of VmaAllocation objects, that can be retrieved using function vmaGetAllocationInfo().</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3231</div></div>
<div class="ttc" id="astruct_vma_allocator_html"><div class="ttname"><a href="struct_vma_allocator.html">VmaAllocator</a></div><div class="ttdoc">Represents main object of this library initialized.</div></div>
<div class="ttc" id="astruct_vma_defragmentation_context_html"><div class="ttname"><a href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a></div><div class="ttdoc">Represents Opaque object that represents started defragmentation process.</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info2_html"><div class="ttname"><a href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a></div><div class="ttdoc">Parameters for defragmentation.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3642</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info2_html_a3cf86ab32c1da779b4923d301a3056ba"><div class="ttname"><a href="struct_vma_defragmentation_info2.html#a3cf86ab32c1da779b4923d301a3056ba">VmaDefragmentationInfo2::allocationCount</a></div><div class="ttdeci">uint32_t allocationCount</div><div class="ttdoc">Number of allocations in pAllocations array.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3648</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info2_html_a94c2c7223d52878445a8cccce396b671"><div class="ttname"><a href="struct_vma_defragmentation_info2.html#a94c2c7223d52878445a8cccce396b671">VmaDefragmentationInfo2::maxCpuAllocationsToMove</a></div><div class="ttdeci">uint32_t maxCpuAllocationsToMove</div><div class="ttdoc">Maximum number of allocations that can be moved to a different place using transfers on CPU side,...</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3692</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info2_html_af78e1ea40c22d85137b65f6b384a4d0a"><div class="ttname"><a href="struct_vma_defragmentation_info2.html#af78e1ea40c22d85137b65f6b384a4d0a">VmaDefragmentationInfo2::maxCpuBytesToMove</a></div><div class="ttdeci">VkDeviceSize maxCpuBytesToMove</div><div class="ttdoc">Maximum total numbers of bytes that can be copied while moving allocations to different places using ...</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3687</div></div>
</div><!-- fragment --><p>Setting VmaDefragmentationInfo2::pAllocationsChanged is optional. This output array tells whether particular allocation in VmaDefragmentationInfo2::pAllocations at the same index has been modified during defragmentation. You can pass null, but you then need to query every allocation passed to defragmentation for new parameters using vmaGetAllocationInfo() if you might need to recreate and rebind a buffer or image associated with it.</p>
<p>If you use <a class="el" href="choosing_memory_type.html#choosing_memory_type_custom_memory_pools">Custom memory pools</a>, you can fill <a class="el" href="struct_vma_defragmentation_info2.html#a7e70aa2a1081d849dcc7829b19d3ec9d" title="Numer of pools in pPools array.">VmaDefragmentationInfo2::poolCount</a> and VmaDefragmentationInfo2::pPools instead of <a class="el" href="struct_vma_defragmentation_info2.html#a3cf86ab32c1da779b4923d301a3056ba" title="Number of allocations in pAllocations array.">VmaDefragmentationInfo2::allocationCount</a> and VmaDefragmentationInfo2::pAllocations to defragment all allocations in given pools. You cannot use VmaDefragmentationInfo2::pAllocationsChanged in that case. You can also combine both methods.</p>
<h1><a class="anchor" id="defragmentation_gpu"></a>
Defragmenting GPU memory</h1>
<p>It is also possible to defragment allocations created in memory types that are not <code>HOST_VISIBLE</code>. To do that, you need to pass a command buffer that meets requirements as described in <a class="el" href="struct_vma_defragmentation_info2.html#aef85e2469af1744e2497990f26d35687" title="Optional. Command buffer where GPU copy commands will be posted.">VmaDefragmentationInfo2::commandBuffer</a>. The way it works is:</p>
<ul>
<li>It creates temporary buffers and binds them to entire memory blocks when necessary.</li>
<li>It issues <code>vkCmdCopyBuffer()</code> to passed command buffer.</li>
</ul>
<p>Example:</p>
<div class="fragment"><div class="line"><span class="comment">// Given following variables already initialized:</span></div>
<div class="line">VkDevice device;</div>
<div class="line"><a class="code" href="struct_vma_allocator.html">VmaAllocator</a> allocator;</div>
<div class="line">VkCommandBuffer commandBuffer;</div>
<div class="line">std::vector&lt;VkBuffer&gt; buffers;</div>
<div class="line">std::vector&lt;VmaAllocation&gt; allocations;</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> uint32_t allocCount = (uint32_t)allocations.size();</div>
<div class="line">std::vector&lt;VkBool32&gt; allocationsChanged(allocCount);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vk_command_buffer_begin_info.html">VkCommandBufferBeginInfo</a> cmdBufBeginInfo = ...;</div>
<div class="line">vkBeginCommandBuffer(commandBuffer, &amp;cmdBufBeginInfo);</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_defragmentation_info2.html">VmaDefragmentationInfo2</a> defragInfo = {};</div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info2.html#a3cf86ab32c1da779b4923d301a3056ba">allocationCount</a> = allocCount;</div>
<div class="line">defragInfo.pAllocations = allocations.data();</div>
<div class="line">defragInfo.pAllocationsChanged = allocationsChanged.data();</div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info2.html#a4ddbc898d0afe1518f863a3763628f08">maxGpuBytesToMove</a> = VK_WHOLE_SIZE; <span class="comment">// Notice it&#39;s &quot;GPU&quot; this time.</span></div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info2.html#a40d53d33e71ba0b66f844ed63c05a3f6">maxGpuAllocationsToMove</a> = UINT32_MAX; <span class="comment">// Notice it&#39;s &quot;GPU&quot; this time.</span></div>
<div class="line">defragInfo.<a class="code" href="struct_vma_defragmentation_info2.html#aef85e2469af1744e2497990f26d35687">commandBuffer</a> = commandBuffer;</div>
<div class="line"> </div>
<div class="line"><a class="code" href="struct_vma_defragmentation_context.html">VmaDefragmentationContext</a> defragCtx;</div>
<div class="line">vmaDefragmentationBegin(allocator, &amp;defragInfo, <span class="keyword">nullptr</span>, &amp;defragCtx);</div>
<div class="line"> </div>
<div class="line">vkEndCommandBuffer(commandBuffer);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Submit commandBuffer.</span></div>
<div class="line"><span class="comment">// Wait for a fence that ensures commandBuffer execution finished.</span></div>
<div class="line"> </div>
<div class="line">vmaDefragmentationEnd(allocator, defragCtx);</div>
<div class="line"> </div>
<div class="line"><span class="keywordflow">for</span>(uint32_t i = 0; i &lt; allocCount; ++i)</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span>(allocationsChanged[i])</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Destroy buffer that is immutably bound to memory region which is no longer valid.</span></div>
<div class="line">        vkDestroyBuffer(device, buffers[i], <span class="keyword">nullptr</span>);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Create new buffer with same parameters.</span></div>
<div class="line">        <a class="code" href="struct_vk_buffer_create_info.html">VkBufferCreateInfo</a> bufferInfo = ...;</div>
<div class="line">        vkCreateBuffer(device, &amp;bufferInfo, <span class="keyword">nullptr</span>, &amp;buffers[i]);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// You can make dummy call to vkGetBufferMemoryRequirements here to silence validation layer warning.</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Bind new buffer to new memory region. Data contained in it is already moved.</span></div>
<div class="line">        <a class="code" href="struct_vma_allocation_info.html">VmaAllocationInfo</a> allocInfo;</div>
<div class="line">        vmaGetAllocationInfo(allocator, allocations[i], &amp;allocInfo);</div>
<div class="line">        vmaBindBufferMemory(allocator, allocations[i], buffers[i]);</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="astruct_vk_command_buffer_begin_info_html"><div class="ttname"><a href="struct_vk_command_buffer_begin_info.html">VkCommandBufferBeginInfo</a></div><div class="ttdef"><b>Definition:</b> vulkan_core.h:3025</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info2_html_a40d53d33e71ba0b66f844ed63c05a3f6"><div class="ttname"><a href="struct_vma_defragmentation_info2.html#a40d53d33e71ba0b66f844ed63c05a3f6">VmaDefragmentationInfo2::maxGpuAllocationsToMove</a></div><div class="ttdeci">uint32_t maxGpuAllocationsToMove</div><div class="ttdoc">Maximum number of allocations that can be moved to a different place using transfers on GPU side,...</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3702</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info2_html_a4ddbc898d0afe1518f863a3763628f08"><div class="ttname"><a href="struct_vma_defragmentation_info2.html#a4ddbc898d0afe1518f863a3763628f08">VmaDefragmentationInfo2::maxGpuBytesToMove</a></div><div class="ttdeci">VkDeviceSize maxGpuBytesToMove</div><div class="ttdoc">Maximum total numbers of bytes that can be copied while moving allocations to different places using ...</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3697</div></div>
<div class="ttc" id="astruct_vma_defragmentation_info2_html_aef85e2469af1744e2497990f26d35687"><div class="ttname"><a href="struct_vma_defragmentation_info2.html#aef85e2469af1744e2497990f26d35687">VmaDefragmentationInfo2::commandBuffer</a></div><div class="ttdeci">VkCommandBuffer VMA_NULLABLE commandBuffer</div><div class="ttdoc">Optional. Command buffer where GPU copy commands will be posted.</div><div class="ttdef"><b>Definition:</b> vk_mem_alloc.h:3711</div></div>
</div><!-- fragment --><p>You can combine these two methods by specifying non-zero <code>maxGpu*</code> as well as <code>maxCpu*</code> parameters. The library automatically chooses best method to defragment each memory pool.</p>
<p>You may try not to block your entire program to wait until defragmentation finishes, but do it in the background, as long as you carefully fullfill requirements described in function vmaDefragmentationBegin().</p>
<h1><a class="anchor" id="defragmentation_additional_notes"></a>
Additional notes</h1>
<p>It is only legal to defragment allocations bound to:</p>
<ul>
<li>buffers</li>
<li>images created with <code>VK_IMAGE_CREATE_ALIAS_BIT</code>, <code>VK_IMAGE_TILING_LINEAR</code>, and being currently in <code>VK_IMAGE_LAYOUT_GENERAL</code> or <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code>.</li>
</ul>
<p>Defragmentation of images created with <code>VK_IMAGE_TILING_OPTIMAL</code> or in any other layout may give undefined results.</p>
<p>If you defragment allocations bound to images, new images to be bound to new memory region after defragmentation should be created with <code>VK_IMAGE_LAYOUT_PREINITIALIZED</code> and then transitioned to their original layout from before defragmentation if needed using an image memory barrier.</p>
<p>While using defragmentation, you may experience validation layer warnings, which you just need to ignore. See <a class="el" href="general_considerations.html#general_considerations_validation_layer_warnings">Validation layer warnings</a>.</p>
<p>Please don't expect memory to be fully compacted after defragmentation. Algorithms inside are based on some heuristics that try to maximize number of Vulkan memory blocks to make totally empty to release them, as well as to maximimze continuous empty space inside remaining blocks, while minimizing the number and size of allocations that need to be moved. Some fragmentation may still remain - this is normal.</p>
<h1><a class="anchor" id="defragmentation_custom_algorithm"></a>
Writing custom defragmentation algorithm</h1>
<p>If you want to implement your own, custom defragmentation algorithm, there is infrastructure prepared for that, but it is not exposed through the library API - you need to hack its source code. Here are steps needed to do this:</p>
<ol type="1">
<li>Main thing you need to do is to define your own class derived from base abstract class <code>VmaDefragmentationAlgorithm</code> and implement your version of its pure virtual methods. See definition and comments of this class for details.</li>
<li>Your code needs to interact with device memory block metadata. If you need more access to its data than it's provided by its public interface, declare your new class as a friend class e.g. in class <code>VmaBlockMetadata_Generic</code>.</li>
<li>If you want to create a flag that would enable your algorithm or pass some additional flags to configure it, add them to <code>VmaDefragmentationFlagBits</code> and use them in <a class="el" href="struct_vma_defragmentation_info2.html#a53e844ee5633e229cf6daf14b2d9fff9" title="Reserved for future use. Should be 0.">VmaDefragmentationInfo2::flags</a>.</li>
<li>Modify function <code>VmaBlockVectorDefragmentationContext::Begin</code> to create object of your new class whenever needed. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
